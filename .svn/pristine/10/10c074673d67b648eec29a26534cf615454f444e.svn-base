<?php
namespace LITE;

abstract class Hooker {
	private static $HOOKS = array();
	private function __construct(){}

	/**
	 * add hooker event
	 * @param string $key
	 * @param string||array $callback
	 * @return boolean
	 **/
	public static function add($key, $callback){
		self::$HOOKS[$key] = self::$HOOKS[$key] ?: array();
		self::$HOOKS[$key][] = $callback;
		return true;
	}

	/**
	 * delete a hooker event
	 * @param $key
	 * @param $callback
	 * @return bool
	 */
	public static function delete($key, $callback){
		if(self::$HOOKS[$key]){
			$rst = array();
			$found = false;
			foreach(self::$HOOKS[$key] as $item){
				if($item != $callback){
					$rst[] = $item;
				} else {
					$found = true;
				}
			}
			if($found){
				self::$HOOKS[$key] = $rst;
				return true;
			}
		}
		return false;
	}

	/**
	 * check has hooker event
	 * @param string $key
	 * @return boolean
	 **/
	public static function exists($key){
		return self::$HOOKS[$key] ? count(self::$HOOKS[$key]) : false;
	}

	/**
	 * trigger one hooker event
	 * @param string $key
	 * @return array
	 **/
	public static function fire($key/** , $param1, $param2 **/){
		$args = array_slice(func_get_args(), 1) ?: array();
		$returns = array();
		if(self::$HOOKS[$key]){
			foreach(self::$HOOKS[$key] as $item){
				$result = call_user_func_array($item, $args);
				if($result === false){
					return false;
				}
				$returns[] = $result;
			}
		}
		return $returns;
	}
}